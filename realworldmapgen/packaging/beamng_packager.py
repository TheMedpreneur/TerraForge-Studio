"""
Create .zip packages for BeamNG.drive /mods/ folder
"""

import logging
import zipfile
from pathlib import Path
from typing import Optional, List

logger = logging.getLogger(__name__)


class BeamNGPackager:
    """Package maps for BeamNG.drive installation"""
    
    def __init__(self):
        pass
    
    def create_mod_package(
        self,
        map_dir: Path,
        map_name: str,
        output_dir: Optional[Path] = None
    ) -> Path:
        """
        Create a .zip package ready for BeamNG.drive /mods/ folder
        
        Args:
            map_dir: Directory containing all map files
            map_name: Name of the map
            output_dir: Where to save the .zip (defaults to map_dir parent)
            
        Returns:
            Path to created .zip file
        """
        logger.info(f"Creating BeamNG.drive mod package for '{map_name}'")
        
        if not map_dir.exists():
            raise FileNotFoundError(f"Map directory not found: {map_dir}")
        
        # Determine output location
        if output_dir is None:
            output_dir = map_dir.parent
        output_dir.mkdir(parents=True, exist_ok=True)
        
        zip_filename = f"{map_name}.zip"
        zip_path = output_dir / zip_filename
        
        # Create zip with proper BeamNG structure
        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            # Add all files with correct structure: levels/map_name/...
            for file_path in map_dir.rglob('*'):
                if file_path.is_file():
                    # Calculate relative path
                    rel_path = file_path.relative_to(map_dir)
                    
                    # Archive path: levels/map_name/file
                    archive_path = f"levels/{map_name}/{rel_path}"
                    
                    zipf.write(file_path, archive_path)
                    logger.debug(f"Added to zip: {archive_path}")
            
            # Add mod info file
            self._add_mod_info(zipf, map_name)
        
        logger.info(f"Created mod package: {zip_path} ({self._format_size(zip_path.stat().st_size)})")
        return zip_path
    
    def _add_mod_info(self, zipf: zipfile.ZipFile, map_name: str):
        """Add mod.json metadata file"""
        mod_info = f'''{{
    "name": "{map_name}",
    "version": "1.0.0",
    "description": "Real-world map generated by RealWorldMapGen-BNG",
    "author": "RealWorldMapGen-BNG",
    "type": "level",
    "files": {{
        "levels/{map_name}": {{
            "type": "level",
            "priority": 100
        }}
    }}
}}'''
        
        zipf.writestr("mod.json", mod_info)
        logger.debug("Added mod.json")
    
    def create_package_with_preview(
        self,
        map_dir: Path,
        map_name: str,
        preview_image: Optional[Path] = None,
        output_dir: Optional[Path] = None
    ) -> Path:
        """
        Create package with preview image
        
        Args:
            map_dir: Map directory
            map_name: Map name
            preview_image: Path to preview/thumbnail image
            output_dir: Output directory
            
        Returns:
            Path to .zip file
        """
        zip_path = self.create_mod_package(map_dir, map_name, output_dir)
        
        if preview_image and preview_image.exists():
            # Add preview to existing zip
            with zipfile.ZipFile(zip_path, 'a') as zipf:
                zipf.write(preview_image, f"levels/{map_name}/preview.jpg")
                logger.info(f"Added preview image: {preview_image.name}")
        
        return zip_path
    
    def verify_package(self, zip_path: Path) -> bool:
        """
        Verify that package has correct structure
        
        Args:
            zip_path: Path to .zip file
            
        Returns:
            True if valid, False otherwise
        """
        required_files = ['mod.json']
        
        try:
            with zipfile.ZipFile(zip_path, 'r') as zipf:
                file_list = zipf.namelist()
                
                # Check for mod.json
                if 'mod.json' not in file_list:
                    logger.error("Missing mod.json in package")
                    return False
                
                # Check for at least one level file
                has_level = any('levels/' in f for f in file_list)
                if not has_level:
                    logger.error("No level files found in package")
                    return False
                
                logger.info(f"Package verified: {len(file_list)} files")
                return True
                
        except zipfile.BadZipFile:
            logger.error(f"Corrupted zip file: {zip_path}")
            return False
    
    def extract_package_info(self, zip_path: Path) -> dict:
        """Extract package metadata"""
        import json
        
        try:
            with zipfile.ZipFile(zip_path, 'r') as zipf:
                if 'mod.json' in zipf.namelist():
                    mod_data = zipf.read('mod.json').decode('utf-8')
                    return json.loads(mod_data)
        except Exception as e:
            logger.error(f"Failed to extract package info: {e}")
        
        return {}
    
    def _format_size(self, size_bytes: int) -> str:
        """Format file size in human-readable format"""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.1f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.1f} TB"
